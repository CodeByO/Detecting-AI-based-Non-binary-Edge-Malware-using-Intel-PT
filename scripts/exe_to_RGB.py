# Binary to Image Converter
# Read executable binary files and convert them RGB and greyscale png images
#
# Author: Necmettin Çarkacı
# E-mail: necmettin [ . ] carkaci [ @ ] gmail [ . ] com
import os, math,sys
from PIL import Image
from tensorflow.keras.models import load_model
import cv2
import numpy as np
from keras import backend as K
sys.path.append(os.path.dirname(os.path.abspath(os.path.dirname(__file__))))
def getBinaryData(filename):
	"""
	Extract byte values from binary executable file and store them into list
	:param filename: executable file name
	:return: byte value list
	"""
	binary_values = []
	with open(filename, 'rb') as fileobject:
		# read file byte by byte
		data = fileobject.read(1)
		while data != b'':
			binary_values.append(ord(data))
			data = fileobject.read(1)
	return binary_values
def createRGBImage(filename, width=None):
	"""
	Create RGB image from 24 bit binary data 8bit Red, 8 bit Green, 8bit Blue
	:param filename: image filename
	"""
	index = 0
	rgb_data = []
	# Read binary file
	binary_data = getBinaryData(filename)
	# Create R,G,B pixels
	while (index + 3) < len(binary_data):
		R = binary_data[index]
		G = binary_data[index+1]
		B = binary_data[index+2]
		index += 3
		rgb_data.append((R, G, B))
	size = get_size(len(rgb_data), width)
	save_file(filename, rgb_data, size, 'RGB')
def save_file(filename, data, size, image_type):
    try:
        root_path = os.path.dirname(os.path.abspath(os.path.dirname(__file__)))
        data_path = os.path.join(root_path,'data')

        image = Image.new(image_type, size)
        image.putdata(data)
		# setup output filename
        dirname     = "normal"
        name, _     = os.path.splitext(filename)
        name        = os.path.basename(name)
        global imagename
        imagename  = data_path + os.sep + dirname + os.sep + image_type + os.sep + name + '_'+image_type+ '.png'
        os.makedirs(os.path.dirname(imagename), exist_ok=True)
        image.save(imagename)
        print('The file', imagename, 'saved.')
    except Exception as err:
        print(err)
def get_size(data_length, width=None):
	# source Malware images: visualization and automatic classification by L. Nataraj
	# url : http://dl.acm.org/citation.cfm?id=2016908
	if width is None: # with don't specified any with value
		size = data_length
		if (size < 10240):
			width = 32
		elif (10240 <= size <= 10240 * 3):
			width = 64
		elif (10240 * 3 <= size <= 10240 * 6):
			width = 128
		elif (10240 * 6 <= size <= 10240 * 10):
			width = 256
		elif (10240 * 10 <= size <= 10240 * 20):
			width = 384
		elif (10240 * 20 <= size <= 10240 * 50):
			width = 512
		elif (10240 * 50 <= size <= 10240 * 100):
			width = 768
		else:
			width = 1024
		height = int(size / width) + 1
	else:
		width  = int(math.sqrt(data_length)) + 1
		height = width
	return (width, height)

def recall_m(y_test, y_pred):
        true_positives = K.sum(K.round(K.clip(y_test * y_pred, 0, 1)))
        possible_positives = K.sum(K.round(K.clip(y_test, 0, 1)))
        recall = true_positives / (possible_positives + K.epsilon())
        return recall

def precision_m(y_test, y_pred):
        true_positives = K.sum(K.round(K.clip(y_test * y_pred, 0, 1)))
        predicted_positives = K.sum(K.round(K.clip(y_pred, 0, 1)))
        precision = true_positives / (predicted_positives + K.epsilon())
        return precision

def f1_m(y_test, y_pred):
        precision = precision_m(y_test, y_pred)
        recall = recall_m(y_test, y_pred)
        return 2 * ((precision * recall) / (precision + recall + K.epsilon()))
    
    
def preprocess_image(image_path):
    image = cv2.imread(image_path)
    image = cv2.resize(image, (64, 64))
    image = image / 255.0
    return image

# 이미지를 모델이 예상하는 형태로 변환
def preprocess_input(image):
    image = np.expand_dims(image, axis=0)
    return image

def run_model():
	image_path = imagename
	root_path = os.path.dirname(os.path.abspath(os.path.dirname(__file__)))
	model_path = os.path.join(root_path,'components')
	model_filename = os.path.join(model_path,'malware_model_RGB.h5')
	if os.path.isfile(model_filename):
		model = load_model(model_filename, custom_objects={'f1_m': f1_m, 'precision_m' : precision_m,'recall_m':recall_m})
		image = preprocess_image(image_path)
		input_data = preprocess_input(image)
		prediction = model.predict(input_data)
		prediction = prediction.tolist()
		result_flat = [item for sublist in prediction for item in sublist]
		return result_flat
def main(input_path, width=None):
    print()
	# Get all executable files in input directory and add them into queue
    createRGBImage(input_path, width)
    prediction = run_model()
    return prediction