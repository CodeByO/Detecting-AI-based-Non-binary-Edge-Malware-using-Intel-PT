import numpy as np
from sklearn.model_selection import train_test_split
from tensorflow.python.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Dropout, Flatten, Dense
from tensorflow.keras.metrics import AUC
from sklearn.utils import class_weight
import pandas as pd
from sklearn import metrics
from keras import backend as K
from keras.preprocessing.image import ImageDataGenerator

def train_malware_model(X_train, y_train, X_test, y_test, num_classes):
    def malware_model():
        Malware_model = Sequential()
        Malware_model.add(Conv2D(30, kernel_size=(3, 3), activation='relu', input_shape=(64, 64, 3)))
        Malware_model.add(MaxPooling2D(pool_size=(2, 2)))
        Malware_model.add(Conv2D(15, (3, 3), activation='relu'))
        Malware_model.add(MaxPooling2D(pool_size=(2, 2)))
        Malware_model.add(Dropout(0.25))
        Malware_model.add(Flatten())
        Malware_model.add(Dense(128, activation='relu'))
        Malware_model.add(Dropout(0.5))
        Malware_model.add(Dense(50, activation='relu'))
        Malware_model.add(Dense(num_classes, activation='softmax'))
        Malware_model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])
        return Malware_model

    def recall_m(y_test, y_pred):
        true_positives = K.sum(K.round(K.clip(y_test * y_pred, 0, 1)))
        possible_positives = K.sum(K.round(K.clip(y_test, 0, 1)))
        recall = true_positives / (possible_positives + K.epsilon())
        return recall

    def precision_m(y_test, y_pred):
        true_positives = K.sum(K.round(K.clip(y_test * y_pred, 0, 1)))
        predicted_positives = K.sum(K.round(K.clip(y_pred, 0, 1)))
        precision = true_positives / (predicted_positives + K.epsilon())
        return precision

    def f1_m(y_test, y_pred):
        precision = precision_m(y_test, y_pred)
        recall = recall_m(y_test, y_pred)
        return 2 * ((precision * recall) / (precision + recall + K.epsilon()))


    Malware_model = malware_model()

    y_train_new = np.argmax(y_train, axis=1)
    class_weights = class_weight.compute_class_weight(class_weight='balanced', classes=np.unique(y_train_new), y=y_train_new)
    class_weights = {l: c for l, c in zip(np.unique(y_train_new), class_weights)}

    Malware_model.compile(optimizer='adam', loss='binary_crossentropy', metrics=[f1_m, precision_m, recall_m, AUC()])
    Malware_model.fit(X_train, y_train, validation_data=(X_test, y_test), epochs=20, class_weight=class_weights)

    scores = Malware_model.evaluate(X_test, y_test)
    loss, accuracy, f1_score, precision, recall = scores[0], scores[1], scores[2], scores[3], scores[4]

    y_pred = np.argmax(Malware_model.predict(X_test), axis=-1)
    y_test2 = np.argmax(y_test, axis=1)
    c_matrix = metrics.confusion_matrix(y_test2, y_pred)

    results = pd.DataFrame({'CNN Model': 'Malware model',
                            'Accuracy': [accuracy],
                            'Loss': [loss],
                            'Precision': [precision],
                            'Recall': [recall],
                            'f1 score': [f1_score]})

    # Save the trained model
    model_filename = 'malware_model_RGB.h5'
    Malware_model.save(model_filename)
    print(f"Trained model saved as {model_filename}")

    return results
def main():
    root = "C:/workspace/RGB"
    batches = ImageDataGenerator().flow_from_directory(directory=root, target_size=(64,64), batch_size=10000)
    # 이미지 데이터와 레이블을 로드하는 코드
    imgs, labels = next(batches)
    labels.shape
    X_train, X_test, y_train, y_test = train_test_split(imgs / 255., labels, test_size=0.3)
    X_train.shape
    X_test.shape
    y_train.shape
    y_test.shape
    num_classes = len(batches.class_indices)

    results = train_malware_model(X_train, y_train, X_test, y_test, num_classes)
    return results
